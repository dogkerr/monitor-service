// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: container_query.sql

package queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const getAllUserContainer = `-- name: GetAllUserContainer :many
SELECT c.id, c.user_id, c.image, c.status, c.name, c.container_port, c.public_port, c.created_time,c.service_id, c.terminated_time,
	cl.id as lifecycleId, cl.start_time as lifecycleStartTime, cl.stop_time as lifecycleStopTime, 
	cl.replica as lifecycleReplica, cl.status as lifecycleStatus FROM containers c  LEFT JOIN container_lifecycles cl ON cl.container_id=c.id
	WHERE c.user_id=$1
`

type GetAllUserContainerRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	Image              string
	Status             ContainerStatus
	Name               string
	ContainerPort      int32
	PublicPort         sql.NullInt32
	CreatedTime        time.Time
	ServiceID          string
	TerminatedTime     sql.NullTime
	Lifecycleid        uuid.NullUUID
	Lifecyclestarttime sql.NullTime
	Lifecyclestoptime  sql.NullTime
	Lifecyclereplica   sql.NullInt32
	Lifecyclestatus    NullContainerStatus
}

func (q *Queries) GetAllUserContainer(ctx context.Context, userID uuid.UUID) ([]GetAllUserContainerRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserContainer, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserContainerRow
	for rows.Next() {
		var i GetAllUserContainerRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Image,
			&i.Status,
			&i.Name,
			&i.ContainerPort,
			&i.PublicPort,
			&i.CreatedTime,
			&i.ServiceID,
			&i.TerminatedTime,
			&i.Lifecycleid,
			&i.Lifecyclestarttime,
			&i.Lifecyclestoptime,
			&i.Lifecyclereplica,
			&i.Lifecyclestatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserContainers = `-- name: GetAllUserContainers :many
SELECT c.id, c.user_id, c.image, c.status, c.name, c.container_port, c.public_port, c.created_time,c.service_id, c.terminated_time,
			cl.id as lifecycleId, cl.start_time as lifecycleStartTime, cl.stop_time as lifecycleStopTime, 
			cl.replica as lifecycleReplica, cl.status as lifecycleStatus FROM containers c  LEFT JOIN container_lifecycles cl ON cl.container_id=c.id
			WHERE c.user_id=$1
`

type GetAllUserContainersRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	Image              string
	Status             ContainerStatus
	Name               string
	ContainerPort      int32
	PublicPort         sql.NullInt32
	CreatedTime        time.Time
	ServiceID          string
	TerminatedTime     sql.NullTime
	Lifecycleid        uuid.NullUUID
	Lifecyclestarttime sql.NullTime
	Lifecyclestoptime  sql.NullTime
	Lifecyclereplica   sql.NullInt32
	Lifecyclestatus    NullContainerStatus
}

func (q *Queries) GetAllUserContainers(ctx context.Context, userID uuid.UUID) ([]GetAllUserContainersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserContainers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserContainersRow
	for rows.Next() {
		var i GetAllUserContainersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Image,
			&i.Status,
			&i.Name,
			&i.ContainerPort,
			&i.PublicPort,
			&i.CreatedTime,
			&i.ServiceID,
			&i.TerminatedTime,
			&i.Lifecycleid,
			&i.Lifecyclestarttime,
			&i.Lifecyclestoptime,
			&i.Lifecyclereplica,
			&i.Lifecyclestatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContainer = `-- name: GetContainer :many
SELECT c.id, c.user_id, c.image, c.status, c.name, c.container_port, c.public_port,c.created_time,
	c.service_id,c.terminated_time, cl.id as lifeId, cl.start_time as lifecycleStartTime, cl.stop_time as lifecycleStopTime, cl.replica  as lifecycleReplica, cl.status as lifecycleStatus 
	FROM containers c LEFT JOIN container_lifecycles cl ON cl.container_id=c.id
	WHERE c.service_id=$1
`

type GetContainerRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	Image              string
	Status             ContainerStatus
	Name               string
	ContainerPort      int32
	PublicPort         sql.NullInt32
	CreatedTime        time.Time
	ServiceID          string
	TerminatedTime     sql.NullTime
	Lifeid             uuid.NullUUID
	Lifecyclestarttime sql.NullTime
	Lifecyclestoptime  sql.NullTime
	Lifecyclereplica   sql.NullInt32
	Lifecyclestatus    NullContainerStatus
}

func (q *Queries) GetContainer(ctx context.Context, serviceID string) ([]GetContainerRow, error) {
	rows, err := q.db.QueryContext(ctx, getContainer, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContainerRow
	for rows.Next() {
		var i GetContainerRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Image,
			&i.Status,
			&i.Name,
			&i.ContainerPort,
			&i.PublicPort,
			&i.CreatedTime,
			&i.ServiceID,
			&i.TerminatedTime,
			&i.Lifeid,
			&i.Lifecyclestarttime,
			&i.Lifecyclestoptime,
			&i.Lifecyclereplica,
			&i.Lifecyclestatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecificContainerMetrics = `-- name: GetSpecificContainerMetrics :one
SELECT m.id, m.cpus, m.memory, m.network_ingress, m.network_egress
	FROM container_metrics m 
	WHERE m.container_id=$1
`

type GetSpecificContainerMetricsRow struct {
	ID             uuid.UUID
	Cpus           float64
	Memory         float64
	NetworkIngress float64
	NetworkEgress  float64
}

func (q *Queries) GetSpecificContainerMetrics(ctx context.Context, containerID uuid.UUID) (GetSpecificContainerMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getSpecificContainerMetrics, containerID)
	var i GetSpecificContainerMetricsRow
	err := row.Scan(
		&i.ID,
		&i.Cpus,
		&i.Memory,
		&i.NetworkIngress,
		&i.NetworkEgress,
	)
	return i, err
}
