// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: container_query.sql

package queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllUserContainer = `-- name: GetAllUserContainer :many
SELECT c.id, c.user_id, c.image, c.status, c.name, c.container_port, c.public_port, c.created_time,c.service_id, c.terminated_time,
	cl.id as lifecycleId, cl.start_time as lifecycleStartTime, cl.stop_time as lifecycleStopTime, 
	cl.replica as lifecycleReplica, cl.status as lifecycleStatus FROM containers c  LEFT JOIN container_lifecycles cl ON cl.container_id=c.id
	WHERE c.user_id=$1
`

type GetAllUserContainerRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	Image              string
	Status             ServiceStatus
	Name               string
	ContainerPort      int32
	PublicPort         sql.NullInt32
	CreatedTime        time.Time
	ServiceID          string
	TerminatedTime     sql.NullTime
	Lifecycleid        uuid.NullUUID
	Lifecyclestarttime sql.NullTime
	Lifecyclestoptime  sql.NullTime
	Lifecyclereplica   sql.NullInt32
	Lifecyclestatus    NullContainerStatus
}

func (q *Queries) GetAllUserContainer(ctx context.Context, userID uuid.UUID) ([]GetAllUserContainerRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserContainer, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserContainerRow
	for rows.Next() {
		var i GetAllUserContainerRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Image,
			&i.Status,
			&i.Name,
			&i.ContainerPort,
			&i.PublicPort,
			&i.CreatedTime,
			&i.ServiceID,
			&i.TerminatedTime,
			&i.Lifecycleid,
			&i.Lifecyclestarttime,
			&i.Lifecyclestoptime,
			&i.Lifecyclereplica,
			&i.Lifecyclestatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserContainers = `-- name: GetAllUserContainers :many
SELECT c.id, c.user_id, c.image, c.status, c.name, c.container_port, c.public_port, c.created_time,c.service_id, c.terminated_time,
			cl.id as lifecycleId, cl.start_time as lifecycleStartTime, cl.stop_time as lifecycleStopTime, 
			cl.replica as lifecycleReplica, cl.status as lifecycleStatus FROM containers c  LEFT JOIN container_lifecycles cl ON cl.container_id=c.id
			WHERE c.user_id=$1
`

type GetAllUserContainersRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	Image              string
	Status             ServiceStatus
	Name               string
	ContainerPort      int32
	PublicPort         sql.NullInt32
	CreatedTime        time.Time
	ServiceID          string
	TerminatedTime     sql.NullTime
	Lifecycleid        uuid.NullUUID
	Lifecyclestarttime sql.NullTime
	Lifecyclestoptime  sql.NullTime
	Lifecyclereplica   sql.NullInt32
	Lifecyclestatus    NullContainerStatus
}

func (q *Queries) GetAllUserContainers(ctx context.Context, userID uuid.UUID) ([]GetAllUserContainersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserContainers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserContainersRow
	for rows.Next() {
		var i GetAllUserContainersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Image,
			&i.Status,
			&i.Name,
			&i.ContainerPort,
			&i.PublicPort,
			&i.CreatedTime,
			&i.ServiceID,
			&i.TerminatedTime,
			&i.Lifecycleid,
			&i.Lifecyclestarttime,
			&i.Lifecyclestoptime,
			&i.Lifecyclereplica,
			&i.Lifecyclestatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContainer = `-- name: GetContainer :many
SELECT c.id, c.user_id, c.image, c.status, c.name, c.container_port, c.public_port,c.created_time,
	c.service_id,c.terminated_time, cl.id as lifeId, cl.start_time as lifecycleStartTime, cl.stop_time as lifecycleStopTime, cl.replica  as lifecycleReplica, cl.status as lifecycleStatus 
	FROM containers c LEFT JOIN container_lifecycles cl ON cl.container_id=c.id
	WHERE c.service_id=$1
`

type GetContainerRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	Image              string
	Status             ServiceStatus
	Name               string
	ContainerPort      int32
	PublicPort         sql.NullInt32
	CreatedTime        time.Time
	ServiceID          string
	TerminatedTime     sql.NullTime
	Lifeid             uuid.NullUUID
	Lifecyclestarttime sql.NullTime
	Lifecyclestoptime  sql.NullTime
	Lifecyclereplica   sql.NullInt32
	Lifecyclestatus    NullContainerStatus
}

func (q *Queries) GetContainer(ctx context.Context, serviceID string) ([]GetContainerRow, error) {
	rows, err := q.db.QueryContext(ctx, getContainer, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContainerRow
	for rows.Next() {
		var i GetContainerRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Image,
			&i.Status,
			&i.Name,
			&i.ContainerPort,
			&i.PublicPort,
			&i.CreatedTime,
			&i.ServiceID,
			&i.TerminatedTime,
			&i.Lifeid,
			&i.Lifecyclestarttime,
			&i.Lifecyclestoptime,
			&i.Lifecyclereplica,
			&i.Lifecyclestatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContainerByServiceIDs = `-- name: GetContainerByServiceIDs :many

SELECT c.id, c.service_id, cl.replica as lifecycleReplica, cl.start_time
	FROM containers c 
	LEFT JOIN container_lifecycles cl ON cl.container_id=c.id
	WHERE c.service_id = ANY($1::varchar[])
`

type GetContainerByServiceIDsRow struct {
	ID               uuid.UUID
	ServiceID        string
	Lifecyclereplica sql.NullInt32
	StartTime        sql.NullTime
}

// IN ($1::UUID[]); -- ini gakbisa
func (q *Queries) GetContainerByServiceIDs(ctx context.Context, dollar_1 []string) ([]GetContainerByServiceIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getContainerByServiceIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContainerByServiceIDsRow
	for rows.Next() {
		var i GetContainerByServiceIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Lifecyclereplica,
			&i.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContainerOwnerByID = `-- name: GetContainerOwnerByID :one
SELECT d.id, d.owner, d.uid
	FROM dashboards d 
	WHERE d.uid=$1
`

type GetContainerOwnerByIDRow struct {
	ID    uuid.UUID
	Owner uuid.UUID
	Uid   string
}

func (q *Queries) GetContainerOwnerByID(ctx context.Context, uid string) (GetContainerOwnerByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getContainerOwnerByID, uid)
	var i GetContainerOwnerByIDRow
	err := row.Scan(&i.ID, &i.Owner, &i.Uid)
	return i, err
}

const getProcessedContainers = `-- name: GetProcessedContainers :many
SELECT c.container_id, c.down_time
	FROM processed_terminated_container c 
	WHERE c.container_id  = ANY($1::UUID[])
`

type GetProcessedContainersRow struct {
	ContainerID uuid.UUID
	DownTime    time.Time
}

func (q *Queries) GetProcessedContainers(ctx context.Context, dollar_1 []uuid.UUID) ([]GetProcessedContainersRow, error) {
	rows, err := q.db.QueryContext(ctx, getProcessedContainers, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProcessedContainersRow
	for rows.Next() {
		var i GetProcessedContainersRow
		if err := rows.Scan(&i.ContainerID, &i.DownTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecificContainerMetrics = `-- name: GetSpecificContainerMetrics :many
SELECT m.id, m.cpus, m.memory, m.network_ingress, m.network_egress, m.created_time
	FROM container_metrics m 
	WHERE m.container_id=$1
`

type GetSpecificContainerMetricsRow struct {
	ID             uuid.UUID
	Cpus           float64
	Memory         float64
	NetworkIngress float64
	NetworkEgress  float64
	CreatedTime    time.Time
}

func (q *Queries) GetSpecificContainerMetrics(ctx context.Context, containerID uuid.UUID) ([]GetSpecificContainerMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSpecificContainerMetrics, containerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecificContainerMetricsRow
	for rows.Next() {
		var i GetSpecificContainerMetricsRow
		if err := rows.Scan(
			&i.ID,
			&i.Cpus,
			&i.Memory,
			&i.NetworkIngress,
			&i.NetworkEgress,
			&i.CreatedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSwarmServiceDetailByServiceIDs = `-- name: GetSwarmServiceDetailByServiceIDs :many
SELECT c.id, c.service_id, c.name, c.user_id
	FROM containers c 
	LEFT JOIN container_lifecycles cl ON cl.container_id=c.id
	WHERE c.service_id = ANY($1::varchar[])
`

type GetSwarmServiceDetailByServiceIDsRow struct {
	ID        uuid.UUID
	ServiceID string
	Name      string
	UserID    uuid.UUID
}

func (q *Queries) GetSwarmServiceDetailByServiceIDs(ctx context.Context, dollar_1 []string) ([]GetSwarmServiceDetailByServiceIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSwarmServiceDetailByServiceIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSwarmServiceDetailByServiceIDsRow
	for rows.Next() {
		var i GetSwarmServiceDetailByServiceIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Name,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTerminatedContainer = `-- name: InsertTerminatedContainer :exec
INSERT INTO processed_terminated_container(
	container_id, down_time
) VALUES (
	$1, $2
)
`

type InsertTerminatedContainerParams struct {
	ContainerID uuid.UUID
	DownTime    time.Time
}

func (q *Queries) InsertTerminatedContainer(ctx context.Context, arg InsertTerminatedContainerParams) error {
	_, err := q.db.ExecContext(ctx, insertTerminatedContainer, arg.ContainerID, arg.DownTime)
	return err
}
